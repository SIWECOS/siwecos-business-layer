#!/usr/bin/perl
use strict;
use warnings;
use POSIX;
use FindBin qw($Bin $Script);
use utf8;

binmode(STDOUT, ":utf8");

my $TRANSLATIONS= "$Bin/translations";
my $LANGUAGE_DIR= "$Bin/lang";
my $LANGUAGE_FILE="siwecos.php";
my $TEMPLATEFILE= "$Bin/$Script.txt";

# Expected headers
my $BACKGROUND   = 'Background';
my $CATEGORY     = 'Category';
my $COMMENT      = 'Comment';
my $CONSEQUENCE  = 'Consequence';
my $DESCRIPTION  = 'Description';
my $DETAILS      = 'Details';
my $HEADLINE     = 'Headline';
my $IMPACT       = 'Impact';
my $LINK         = 'Link';
my $ERROR_TEXT   = 'Negative';
my $SUCCESS_TEXT = 'Positive';
my $TIPP         = 'Solution_Tips';
my $TECHNICAL    = 'Technical';

my %CLEAN= (
    $BACKGROUND   => \&trim_escape,
    $CATEGORY     => \&no_linefeeds,
    $COMMENT      => \&trim_escape,
    $CONSEQUENCE  => \&trim_escape,
    $DESCRIPTION  => \&trim_escape,
    $DETAILS      => \&trim_escape,
    $HEADLINE     => \&trim_escape,
    $IMPACT       => \&trim_escape,
    $LINK         => \&wiki_link,
    $ERROR_TEXT   => \&trim_escape,
    $SUCCESS_TEXT => \&trim_escape,
    $TIPP         => \&trim_escape,
    $TECHNICAL    => \&trim_escape,
);

# Prepare some output stuff
my @SUFFIX;
my %SUFFIX;
my $fill= 0;
my $v=0;
foreach (
    $HEADLINE     => '',
    $SUCCESS_TEXT => 'SUCCESS',
    $ERROR_TEXT   => 'ERROR',
    $DESCRIPTION  => 'ERROR_DESC',
    $TIPP         => 'TIPS',
    $LINK         => 'LINK',
) {
    if ($v) {
        my $suffix= $_;
        $suffix= "_$_" if $_;
        $SUFFIX{$SUFFIX[$#SUFFIX]}= $suffix;
        my $l= length $suffix;
        $fill= $l if $l > $fill;
    } else {
        push @SUFFIX, $_;
    }
    $v= 1-$v;
}

my $WIKI= 'https://siwecos.de/wiki';

my %replace= (
    "\\" => "\\\\",
    "\n" => "\\n",
    "'"  => "\\'",
);
my $replace= qr/(\\|\n|')/;

# First prepare the template
open my $template, '<', $TEMPLATEFILE or die "Cannot read template $0.txt: $!\n";
my @template= <$template>;
close $template;



chdir $TRANSLATIONS or die "Cannot change directory to $TRANSLATIONS: $!\n";
# get all translation filenames
# Directory structure is $TRANSLATIONS / placeholder / purpose / language ".txt"
# Also collect categories
my $language_data= {};
my $categories= {};
while (<*/*/*.txt>) {
    # Split pathname into parts
    my ($placeholder, $purpose, $lang)= split m#/#, $_, 3;
    # remove filename extension
    $lang=~ s#\.[^./]+$##;
    # Read the file
    if( open my $trans, '<', $_ ) {
        binmode($trans, ":utf8");
        # into our data structures
        my $text= do {
            local $/;
            <$trans>;
        };
        my $clean= $CLEAN{$purpose};
        if( $clean ) {
            $text= $clean->($text);
        } else {
            $CLEAN{$purpose}= \&trim_escape;
            warn "Unknown purpose: $purpose used in $placeholder.\n";
        }
        if( $purpose eq "Category" ) {
            $language_data->{$lang}->{$placeholder} ||= {};
            $categories->{$lang}->{$text}->{$placeholder}= $language_data->{$lang}->{$placeholder};
        } else {
            $language_data->{$lang}->{$placeholder}->{$purpose}= $text;
        }
    }
    else {
        warn "Can't read $_: $!";
    }
}

if ( -e $LANGUAGE_DIR ) {
    rename $LANGUAGE_DIR, $LANGUAGE_DIR . "_" . strftime("%Y-%m-%d_%H-%M-%S", localtime time);
}
mkdir "$LANGUAGE_DIR" or die "Failed to create directory $LANGUAGE_DIR: $!\n";

# Go through each language
foreach my $language (keys %$categories) {
    my $cats= $categories->{$language};
    # Create a directory for the language
    mkdir "$LANGUAGE_DIR/$language" or die "Failed to create directory $LANGUAGE_DIR/$language: $!\n";
    # Create the language file for the current language
    open my $out, '>', "$LANGUAGE_DIR/$language/$LANGUAGE_FILE"
    or die "Failed to create $LANGUAGE_DIR/$language/$LANGUAGE_FILE: $!\n";
    binmode($out, ':utf8');
    # Work through the template lines
    foreach (@template) {
        # Until the placeholder /* DATA HERE */ is found
		if( m#^(\s*)/\*\s*DATA\s*HERE\s*\*/\s*#)  {
            # Remember the indent
            my $indent= $1;
            # Go through each category in alphabetical order
            foreach my $category (sort keys %$cats) {
                # Print the category as comment
                print $out "$indent//\n$indent// Category: $category\n";
                my $placeholders= $cats->{$category};
                # Go through each placeholder in alphabetical order
                foreach my $placeholder (sort keys %$placeholders){
                    # Print the placeholder as a comment
                    print $out "$indent//\n$indent// $placeholder\n";
                    my $p= $placeholders->{$placeholder};
                    # Go through each of the purposes we want to print
                    # They are defined at the top under "# Prepare some output stuff"
                    foreach my $purpose (@SUFFIX) {
                        my $text= $p->{$purpose};
                        # Skip this entry if there is nothing to be printed
                        next unless defined $text;
                        my $suffix= $SUFFIX{$purpose};
                        my $fillstring= ' ' x ($fill - length $suffix);
                        print $out "$indent'$placeholder$suffix'$fillstring => '$text',\n";
                    }
                }
            }
		} else {
            # Print an unmodified template line
    		print $out $_;
		}
	}
}

# trim leading and trealing whitespace
sub trim {
    local($_)= @_;
    s/^\s+|\s+$//gs;
    return $_;
}

# trim + replace quotes and linefeeds
# Check %replace at the top
sub trim_escape {
    local($_)= trim(@_);
    s/$replace/$replace{$1}/ge;
    return $_;
}

# Replace all whitespace (after trimming) by underscores
sub no_whitespace {
    local($_)= trim(@_);
    s/\s+/_/gs;
    return $_;
}

# replace all linefeeds by underscores
sub no_linefeeds {
    local($_)= trim(@_);
    s/\n/_/gs;
    return $_;
}

# prepend the wiki url
sub wiki_link {
    local($_)= no_linefeeds(@_);
    return "$WIKI/$_";
}
